module Elm.Type.Partial exposing
    ( decoder
    , Partial(..), parse
    )

{-| This is specifically for handling the types that appear in
documentation generated by `elm-make`. If you are looking to parse
arbitrary type signatures with creative indentation (e.g. newlines
and comments) this library will not do what you want. Instead,
check out the source code and go from there. It's not too tough!

@docs Type, decoder

-}

import Char
import Elm.Type as Type exposing (Type)
import Json.Decode as Decode exposing (Decoder)
import Parser exposing (..)
import Set
import String



-- TYPES


{-| Represent Elm types as values! Here are some examples:

    f            ==> Unknown "f"

    a ->         ==> LambdaFrom (Type.Var "a")

    -> a         ==> LambdaTo (Type.Var "a")

    f a        ==> VariableType "f" [ Type.Var "a" ]

    { a | x : Float, y ==> Record [("x", Type.Type "Float" []), ("y", Unknown "")] (Just "a")

-}
type Partial
    = Unknown String
    | LambdaFrom Type
    | LambdaTo Type
    | VariableType String (List Type)
    | Record (List ( String, Type )) (Maybe String)



-- DECODE


{-| Decode the JSON representation of `Partial` values.
-}
decoder : Decoder Partial
decoder =
    Decode.andThen decoderHelp Decode.string


decoderHelp : String -> Decoder Partial
decoderHelp string =
    case parse string of
        Err error ->
            Decode.fail "TODO"

        Ok actualType ->
            Decode.succeed actualType



-- PARSE TYPES


parse : String -> Result (List DeadEnd) Partial
parse source =
    Parser.run partial source


partial : Parser Partial
partial =
    lazy <|
        \_ ->
            andThen tipeHelp tipeTerm


tipeHelp : Partial -> Parser Partial
tipeHelp t =
    oneOf
        [ map LambdaFrom arrowThenType
        , map LambdaTo arrowThenType
        , succeed t
        ]


arrowThenType : Parser Type
arrowThenType =
    succeed identity
        |. backtrackable Type.spaces
        |. Type.arrow
        |. Type.spaces
        |= Type.tipe


tipeTerm : Parser Partial
tipeTerm =
    oneOf
        []
